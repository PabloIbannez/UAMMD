/*Raul P. Pelaez 2017.
  

  References:
  See J. Chem. Phys. 137, 064106 (2012); doi: 10.1063/1.4742347

*/
#include"BDHI_Lanczos.cuh"
#include"misc/Transform.cuh"
#include"Interactor/NBodyForces.cuh"
#include<fstream>
using namespace std;
using namespace BDHI;

Lanczos::Lanczos(real M0, real rh, int N, int max_iter):
  BDHI_Method(M0, rh, N),
  h_work_size(0), d_work(nullptr), d_info(nullptr),
  max_iter(max_iter),  
  w(N),
  V(3*N*max_iter),
  H(max_iter*max_iter), Htemp(max_iter*max_iter),
  P(max_iter*max_iter), Pt(max_iter*max_iter),
  hdiag(max_iter), hsup(max_iter), hdiag_temp(max_iter),  
  utilsRPY(rh){
  cerr<<"\tInitializing Lanczos subsystem...";  



  BLOCKSIZE = 1024;
  Nthreads = BLOCKSIZE<N?BLOCKSIZE:N;
  Nblocks  =  N/Nthreads +  ((N%Nthreads!=0)?1:0); 

  /*Init cuSolver and cuBLAS for Lanczos process*/
  status = cublasCreate(&cublas_handle);
  if(status){cerr<<"ERROR with CUBLAS!!\n"<<endl; exit(1);}
  cusolverDnCreate(&solver_handle);
  h_work_size = 0;//work size of operation  
  cusolverDngesvd_bufferSize(solver_handle, max_iter, max_iter, &h_work_size);

  gpuErrchk(cudaMalloc(&d_work, h_work_size));
  gpuErrchk(cudaMalloc(&d_info, sizeof(int)));

  cerr<<"DONE!!"<<endl;  
}

  
Lanczos::~Lanczos(){
    cublasDestroy(cublas_handle);
}

namespace Lanczos_ns{
  /*Compute the product Mv = M·v, computing M on the fly when needed, without storing it*/
  /*This critital compute is the 99% of the execution time in a BDHI simulation*/
  /*Each thread handles one particle with the other N, including itself*/
  /*That is 3 full lines of M, or 3 elements of M·v per thread, being the x y z of ij with j=0:N-1*/
  /*In other words. M is made of NxN boxes of size 3x3,
    defining the x,y,z mobility between particle pairs, 
    each thread handles a row of boxes and multiplies it by three elements of v*/
  /*vtype can be real3 or real4*/
  template<class vtype>
  struct NbodyFreeMatrixMobilityDot{    
    typedef real3 computeType;
    typedef real3 infoType;
    NbodyFreeMatrixMobilityDot(vtype* v,
			       real3 *Mv,
			       BDHI::RPYUtils utilsRPY,
			       real M0):
      v(v), Mv(Mv), utilsRPY(utilsRPY), M0(M0){}
    /*Start with 0*/
    inline __device__ computeType zero(){ return make_real3(0);}

    inline __device__ infoType getInfo(int pi){
      return make_real3(v[pi]);
    }
    /*Just count the interaction*/
    inline __device__ computeType compute(const real4 &pi, const real4 &pj,
					  const infoType &vi, const infoType &vj){
      /*Distance between the pair*/
      const real3 rij = make_real3(pi)-make_real3(pj);
      const real r = sqrtf(dot(rij, rij));
      /*Compute RPY coefficients, see more info in BDHI::RPYutils::RPY*/
      real2 c12 = utilsRPY.RPY(r);

      const real f = c12.x;
      const real g = c12.y;

      real3 Mv_t;
      /*Update the result with Dij·vj, the current box dot the current three elements of v*/
      /*This expression is a little obfuscated, Mij*vj*/
      /*
	M = f(r)*I+g(r)*r(diadic)r - > (M·v)_ß = f(r)·v_ß + g(r)·v·(r(diadic)r)
	Where f and g are the RPY coefficients
      */
      
      const real gv = dot(g*rij, vj);
      /*gv = g(r)·( vx·rx + vy·ry + vz·rz )*/
      /*(g(r)·v·(r(diadic)r) )_ß = gv·r_ß*/
      Mv_t.x = f*vj.x + gv*rij.x;
      Mv_t.y = f*vj.y + gv*rij.y;
      Mv_t.z = f*vj.z + gv*rij.z;
      return Mv_t;
    }
    /*Sum the result of each interaction*/
    inline __device__ void accumulate(computeType &total, const computeType &cur){total += cur;}

    /*Write the final result to global memory*/
    inline __device__ void set(const computeType &total, int id){
      Mv[id] = M0*total;
    }
    vtype* v;
    real3* Mv;
    real M0;
    BDHI::RPYUtils utilsRPY;
  };
}

void Lanczos::computeMF(real3* MF, cudaStream_t st){
  typedef typename Lanczos_ns::NbodyFreeMatrixMobilityDot<real4> myTransverser;
  
  myTransverser Mv_tr(force.d_m, MF, utilsRPY, M0);
 
  NBodyForces<myTransverser> nbody_Mdot(Mv_tr);
  
  nbody_Mdot.sumForce();
}


void Lanczos::computeBdW(real3 *BdW, cudaStream_t st){
  cublasSetStream(cublas_handle, st);
  cusolverDnSetStream(solver_handle, st);
  curandSetStream(curng, st);
  /*See J. Chem. Phys. 137, 064106 (2012); doi: 10.1063/1.4742347*/
  
  /*For M·v product. Being M the Mobility and v an arbitrary array. 
    The M·v product can be seen as an Nbody interaction Mv_j = sum_i(Mij*vi)
    Where Mij = RPY( |rij|^2 ).
    
    Although M is 3Nx3N, it is treated as a Matrix of NxN boxes of size 3x3,
    and v is a vector3.
   */
  /*Just to make the name cleaner*/
  typedef typename Lanczos_ns::NbodyFreeMatrixMobilityDot<real3> MdotTransverser;
  /*Start the transverser with no v nor Mv pointers*/
  MdotTransverser Mv_tr(nullptr, nullptr, utilsRPY, M0);
  /*Initialize the Nbody module*/
  NBodyForces<MdotTransverser> nbody_Mdot(Mv_tr, st);
    
  /************v[0] = z/||z||_2*****/
  /*Compute noise*/       /*V.d_m -> first column of V*/
  curandGenerateNormal(curng, V.d_m, 3*N + ((3*N)%2), real(0.0), real(1.0));
  /*1/norm(z)*/
  real invz2; cublasnrm2(cublas_handle, 3*N, V.d_m, 1, &invz2);
  cudaStreamSynchronize(st);
  invz2 = 1.0/invz2;

  /*v[0] = v[0]*1/norm(z)*/ 
  cublasscal(cublas_handle, 3*N, &invz2,  V.d_m, 1);
  
  real alpha=1.0;
  /*Lanczos iterations for Krylov decomposition*/
  int i;
  for(i=0; i<max_iter; i++){
    /*w = D·vi ---> See NbodyFreeMatrixMobilityDot on how this works*/
    Mv_tr.v  = (real3 *)(V.d_m+3*N*i); /*src*/
    Mv_tr.Mv = w.d_m;                  /*Result*/
    nbody_Mdot.transverse(Mv_tr);
    
    //D.dot(V.d_m+3*N*i, (real*)w.d_m, handle);
    
    if(i>0){
      /*w = w-h[i-1][i]·vi*/
      alpha = -hsup[i-1];
      cublasaxpy(cublas_handle, 3*N,
		 &alpha,
		 V.d_m+3*N*(i-1), 1,
		 (real *)w.d_m, 1);
    }

    /*h[i][i] = dot(w, vi)*/
    cublasdot(cublas_handle, 3*N,
	      (real *)w.d_m, 1,
	      V.d_m+3*N*i, 1,
	      &(hdiag[i]));
    if(i<(int)max_iter-1){
      cudaStreamSynchronize(st);
      /*w = w-h[i][i]·vi*/
      alpha = -hdiag[i];
      cublasaxpy(cublas_handle, 3*N,
		 &alpha,
		 V.d_m+3*N*i, 1,
		 (real *)w.d_m, 1);
      /*h[i+1][i] = h[i][i+1] = norm(w)*/
      cublasnrm2(cublas_handle, 3*N, (real*)w.d_m, 1, &(hsup[i]));
      cudaStreamSynchronize(st);
      /*v_(i+1) = w·1/ norm(w)*/
      if(hsup[i]>real(0.0)){
	real invw2 = 1.0/hsup[i];
	cublasscal(cublas_handle, 3*N, &invw2,  (real *)w.d_m, 1);
      }
      else{/*If norm(w) = 0 that means all elements of w are zero, so set the first to 1*/
	real one = 1;
	cudaMemcpy(w.d_m, &one , sizeof(real), cudaMemcpyHostToDevice);
      }
      cudaMemcpyAsync(V.d_m+3*N*(i+1), w.d_m, 3*N*sizeof(real), cudaMemcpyDeviceToDevice, st);
    }
  }
  
  /*Compute BdW using h and dw*/
  this->compNoise(1.0/invz2, N, i-1, (real *)BdW);
  
}

void Lanczos::compNoise(real z2, int N, int iter, real * BdW){
  cublasSetStream(cublas_handle, 0);
  cusolverDnSetStream(solver_handle, 0);
  curandSetStream(curng, 0);

  real alpha = 1.0;
  real beta = 0.0;

  fori(0,iter) hdiag_temp[i] = hdiag[i];
  
  /**** y = ||z||_2 * Vm · H^1/2 · e_1 *****/


  /*Compute H^1/2 by diagonalization***********/
  /* H^1/2 = P · Hdiag^1/2 · P^T */
  /******WITH CUSOLVER SVD****************/
  fori(0,iter*iter) H.data[i] = 0;
  fori(0,iter){
    H.data[i*iter+i] = hdiag_temp[i];
    if((uint)i<iter-1){
      H.data[(i+1)*iter+i] = hsup[i];
    }
    if(i>0){
      H.data[(i-1)*iter+i] = hsup[i-1];
    }
  }

  H.upload(iter*iter);
  /*Diagonalize H*/

  cusolverDngesvd(solver_handle, 'A', 'A', iter, iter,
		  H.d_m, iter,
		  hdiag_temp.d_m,
		  P.d_m, iter,
		  Pt.d_m, iter,
		  d_work, h_work_size, nullptr ,d_info);  
  
  hdiag_temp.download(iter);
  
  /*sqrt H*/
  fori(0, iter){
    if(hdiag_temp[i]>0)
      hdiag_temp[i] = sqrt(hdiag_temp[i]);
    else hdiag_temp[i] = 0.0;
  }    
  /* store in hdiag_temp -> H^1/2·e1 = P·Hdiag_Temp^1/2·Pt·e1*/
  fori(0,iter*iter) H.data[i] = 0;
  fori(0,iter) H.data[i*iter+i] = hdiag_temp[i];
  
  H.upload(iter*iter);  
  cublasgemm(cublas_handle,
    	     CUBLAS_OP_N, CUBLAS_OP_N,
    	     iter,iter,iter,
    	     &alpha,
    	     H, iter,
    	     Pt, iter,
    	     &beta,
    	     Htemp,  iter);
  cublasgemm(cublas_handle,
    	     CUBLAS_OP_N,  CUBLAS_OP_N,
    	     iter, iter, iter,
    	     &alpha,
    	     P, iter,
    	     Htemp, iter,
    	     &beta,
   	     H, iter);
  /*Now H contains H^1/2*/  
  /*Store H^1/2 · e1 in hdiag_temp*/
  /*hdiag_temp = H^1/2·e1*/
  cudaMemcpy(hdiag_temp.d_m, H.d_m, iter*sizeof(real), cudaMemcpyDeviceToDevice);
  
  /*noise = ||z||_2 * Vm · H^1/2 · e1 = Vm · (z2·hdiag_temp)*/
  beta = 0.0;
  cublasStatus_t st = cublasgemv(cublas_handle, CUBLAS_OP_N,
				 3*N, iter,
				 &z2,
				 V, 3*N,
				 hdiag_temp.d_m, 1,
				 &beta,
				 BdW, 1);
  /*Print BdW*/
  // noise.download();
  //  ofstream out("noiseLanc.dat");
  //  fori(0,3*N)
  //    out<<((real*)noise.data)[i]<<endl;
  //  exit(0);
 
}



void Lanczos::computeDivM(real3* divM, cudaStream_t st){
   BDHI::divMTransverser divMtr(divM, M0, utilsRPY.rh);
  
   NBodyForces<BDHI::divMTransverser> nbody_divM(divMtr);
  
   nbody_divM.sumForce();
}
